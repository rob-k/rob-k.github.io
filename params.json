{
  "name": "CRDTdroid",
  "tagline": "",
  "body": "# Getting Started\r\n\r\nAlso see the [JavaDoc](/javadoc).\r\n\r\n## 1. Include the Framework\r\n\r\n### Gradle\r\nFor Gradle, add this dependency to your `build.gradle` in the `dependencies {...}` section:\r\n\r\n```properties\r\ncompile 'de.uulm.vs.android.crdtframework:crdtframework:0.4'\r\n```\r\n\r\nWhile the repository is not available in jcenter, you also have to add the Bintray repository to your module by editing your `build.gradle`:\r\n\r\n```properties\r\nrepositories {\r\n    maven {\r\n        url 'https://dl.bintray.com/rob-k/crdt-framework/'\r\n    }\r\n}\r\n```\r\n\r\n### Maven\r\nFor Maven, add this dependency to your `pom.xml` in the `<dependecies>...</dependecies>` section: \r\n```xml\r\n<dependency>\r\n  <groupId>de.uulm.vs.android.crdtframework</groupId>\r\n  <artifactId>crdtframework</artifactId>\r\n  <version>0.3</version>\r\n  <type>pom</type>\r\n</dependency>\r\n```\r\n\r\nWhile the repository is not available in jcenter, you also have to configure your Maven `settings.xml` file to resolve artifacts through Bintray (taken from [the Bintray docs](https://bintray.com/docs/usermanual/formats/formats_mavenrepositories.html#anchorMavenResolve)):\r\n\r\n```xml\r\n <?xml version='1.0' encoding='UTF-8'?>\r\n <settings xsi:schemaLocation='http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd' xmlns='http://maven.apache.org/SETTINGS/1.0.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\r\n <profiles>\r\n    <profile>\r\n        <repositories>\r\n            <repository>\r\n                <snapshots>\r\n                    <enabled>false</enabled>\r\n                </snapshots>\r\n                <id>bintray-<username>-maven</id>\r\n                <name>bintray</name>\r\n                <url>https://dl.bintray.com/jaycroaker/maven</url>\r\n            </repository>\r\n        </repositories>\r\n        <pluginRepositories>\r\n            <pluginRepository>\r\n                <snapshots>\r\n                    <enabled>false</enabled>\r\n                </snapshots>\r\n                <id>bintray-<username>-maven</id>\r\n                <name>bintray-plugins</name>\r\n                <url>https://dl.bintray.com/jaycroaker/maven</url>\r\n            </pluginRepository>\r\n        </pluginRepositories>\r\n        <id>bintray</id>\r\n    </profile>\r\n </profiles>\r\n <activeProfiles>\r\n    <activeProfile>bintray</activeProfile>\r\n </activeProfiles>\r\n </settings>\r\n```\r\n\r\n## 2. Require Permissions\r\n\r\nAdd the following lines to your `AndroidManifest.xml` to make your app ask for the required permissions.\r\n\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    package=\"de.uulm.vs.android.crdtsampleapp\"\r\n    android:versionCode=\"1\"\r\n    android:versionName=\"1.0\" >\r\n\r\n    ...\r\n\r\n    <!-- Add these lines if you want to support Wi-Fi P2P (recommended): -->\r\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\r\n    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\r\n    <uses-permission android:name=\"android.permission.CHANGE_NETWORK_STATE\" />\r\n    <uses-permission android:name=\"android.permission.INTERNET\" />\r\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n\r\n    <!-- Add these lines if you want to support Bluetooth (optional): -->\r\n    <uses-permission android:name=\"android.permission.BLUETOOTH\" android:required=\"false\"/>\r\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" android:required=\"false\"/>\r\n\r\n    ...\r\n\r\n</manifest>\r\n```\r\n\r\n\r\n## 3. Create a CRDTController and ConnectionHandler and hook them up\r\n\r\nYou can do this in the `onCreate()` method of either one of your `Activity`s or, preferably, in your `Application`. \r\n\r\nFor both the Wi-Fi P2P and the Bluetooth communication modules you will need to create a unique Version 4 UUID in order for the framework to only replicate with other devices running your app (you can simply generate a UUID with tools like [https://www.uuidgenerator.net/](https://www.uuidgenerator.net/)).\r\n\r\nExample using the Wi-Fi P2P communication module:\r\n```java\r\n/* The CRDTController instance to handle CRDTs */\r\npublic CRDTController crdtController;\r\n\r\n/* The connection handler to handle connections with other devices */\r\npublic ExchangeConnectionHandler wifip2pConnectionHandler;\r\n\r\n/* A randomly generated UUID for this application.\r\n * REPLACE THIS with your own UUID! */\r\nprivate static final String APP_UUID = \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\";\r\n\r\n@Override\r\npublic void onCreate() {\r\n\r\n    if (this.crdtController == null) {\r\n        // Create a new CRDT changeListener to handle the CRDTs\r\n        this.crdtController = new CRDTController(this);\r\n    }\r\n\r\n    if (this.wifip2pConnectionHandler == null) {\r\n        // Create a new WiFiDirectBroadcastReceiver to handle WiFiP2P connections\r\n        this.wifip2pConnectionHandler = new WiFiDirectBroadcastReceiver(this, \r\n                APP_UUID, crdtController.getClientId(),\r\n                this.crdtController);\r\n        crdtController.addConnectionHandler(wifip2pConnectionHandler);\r\n    }\r\n\r\n    // Initially start device discovery and every 60 seconds after\r\n    crdtController.startScheduledDiscovery(60);\r\n\r\n    super.onCreate();\r\n}\r\n```\r\n\r\n## 4. Make the App register and unregister the BroadcastReceivers and save the data of the CRDT-Framework to the device storage\r\n\r\nThis should be done in the `onResume()` and `onPause()` methods of your `Activity`s. It is recommended to outsource this code to a method that will be called in all activities (e.g. once again, in your `Application`), if you have more than one activity .\r\n\r\n```java\r\n/**\r\n * Registers the broadcast receivers with the intent values to be matched.\r\n * Can be called by activities as default implementation for\r\n * {@link android.app.Activity#onResume()}.\r\n */\r\npublic void onResume() {\r\n    crdtController.registerReceivers();\r\n}\r\n\r\n/**\r\n * Unregisters the broadcast receivers and makes the CRDTController \r\n * save its data to the device storage.\r\n * Can be called by activities as default implementation for \r\n * {@link android.app.Activity#onPause()}.\r\n */\r\npublic void onPause() {\r\n    crdtController.unregisterReceivers();\r\n\r\n    // Save the data to the device storage\r\n    crdtController.saveToStorage();\r\n}\r\n```\r\n\r\n## 5. Get a CRDT-Instance\r\n\r\nTo get instances of new CRDTs call the `newXXXCRDT(id, ...)` methods of your `CRDT-Controller` instance. The `id` is a `String` that is used as identifier for the instance. Additional parameters are mostly default values.\r\n\r\nCall `getCRDT(id)` to get instances back that have been created previously.\r\n\r\nPossible use cases:\r\n\r\n- access instances created in another activity\r\n- access instances created in an ealier session (that have been persisted by the framework)\r\n- access instances that were created by another client (and replicated by the framework)\r\n\r\n### Example\r\nYou will often want to check if the CRDT with an specific identifier has already been created before creating a new instance, as shown in the example below:\r\n```java\r\n...\r\nprivate final String COUNTER_CRDT = \"myCounterCRDT\";\r\nprivate CounterCRDT myCounterCRDT;\r\n\r\n@Override\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n\r\n    ...\r\n\r\n    if ((myCounterCRDT = (CounterCRDT) crdtController\r\n            .getCRDT(COUNTER_CRDT)) == null) {\r\n        myCounterCRDT = crdtController.newCounterCRDT(COUNTER_CRDT, 0);\r\n    }\r\n\r\n    ...\r\n\r\n}\r\n```\r\n\r\n\r\n## 6. Interact with the Controller\r\n\r\n### Start discovery\r\n\r\nDiscovery of other devices (for all registered connection handlers) can be be initiated manually by calling `startDiscovery()`, or automatically every X seconds by using `startScheduledDiscovery(X)`. You usually want to do this right after the controller has been initiated.\r\n\r\n### Commit changes\r\n\r\nChanges from other devices will be received on contact. However, if a connection to one or more devices is already existent, your changes can be commited to be sent over this connection immediately with `commitChanges()`. This will result in an attempt to push on all registered connection handlers. In most cases you will want to call this method after every significant change to your CRDTs.\r\n\r\n### Receive notifications\r\n\r\nYou can register one or more listeners in order to receive notifcations about changes to the framework. This listeners must implement the `CRDTNotificationReceiver` interface and can be added with `addListener(listener);`. \r\n\r\nNotifications include successful merges, replication start and end, as well as errors. The most important interface method is `mergeCompleted()`, which signals that an update from another devices has been received and was successfully merged, which enables you to update the UI accordingly.\r\n\r\nAdditionally, information about available peers for both Bluetooth and Wi-Fi P2P and the respective states of these frameworks can be received.\r\n\r\n### Transactions\r\n\r\nYou can group a set of changes to your CRDTs or simply delay the merge of received and local changes by using a transaction. This can also be used if two or more CRDTs semantically belong together and should never be replicated seperately.\r\n\r\n#### Start a transaction\r\n\r\nCall the `beginTransaction()` method of your `CRDT-Controller` instance. After this call the framework will use a deep copy of your CRDTs on contact with other devices and received changes will be queued till the transaction is finished. Calling `commitChanges()` while a transaction is active will result in an error.\r\n\r\n#### Rollback the transaction\r\n\r\nCall `rollbackTransaction()` if you want to revert all changes that have been made within the current transaction. All queued changes will be merged now.\r\n\r\n#### Commit the transaction\r\nCall `commitTransaction()` to finish the transaction. This will automatically call `commitChanges()` and all queued changes will be merged.\r\n\r\n## 7. Common Data Types\r\n\r\n### Counter \r\n\r\nA `CounterCRDT` is basically a number that can be incremented by 1 using `increment()` or by n using `increment(n)`, decrementation respectively.\r\n\r\n### VectorClock\r\n\r\nA `VectorClockCRDT` is a modified counter that is interpreted as integer vector and can be compared with other instances regarding their causal order (`EQUAL`, `AFTER`, `BEFORE` or `CONCURRENT`). The value of a specific client can be accessed with `getTimestamp(clientId)`.\r\n\r\n### Voter\r\n\r\nA `VoterCRDT` is another modified counter that can be used to represent up- and downvotes on a matter. Every client can upvote (`upvote()`) or downvote (`downvote()`), but they can only vote once (i.e. they can modify the counter by `+-1`). Subsequent upvote/downvote calls will result in a 'revoke' of the vote (e.g. calling `upvote()` twice by the same client will result in the counter changing by `+-0`).\r\n\r\n### Set\r\n\r\nThe `LWWSetCRDT<T>` is a set that supports `add(object)` and `remove(object)` operations. It implements the LWW (last write wins) strategy by utilizing vector clocks.\r\n\r\n### Maximum\r\n\r\nThe `MaximumCRDT` is a simple maximum implementation that holds an integer number and supports a `setMaximum(int)` method, which will max out the current and the new int.\r\n\r\n### What should I do if I need a data type that is not covered by an existing implementation?\r\n\r\nYou can combine existing implementations by using one or more `CRDTMapCRDT`s while using the same keys.\r\n\r\nYou can also write your own CRDT implementation by implementing the `SimpleCRDT` interface and adding your instance(s) with `handleSimpleCRDTs(simpleCrdts)`. Make sure to provide a proper `merge(other)` implementation. \r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}